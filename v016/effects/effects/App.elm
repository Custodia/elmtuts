import Html
import Html.Events as Events
import Http
import Task
import Debug
import Effects

-- NoOp == Nothing happened
-- Refresh -> Triggers ajax request
-- OnRefresh == Refresh has finished. Contains results as payload.
type Action
  = NoOp
  | Refresh
  | OnRefresh (Result Http.Error String)


type alias Model = String


-- The html. Contains refresh button that sends Refresh action to mailbox.
view : Signal.Address Action -> Model -> Html.Html
view address message =
  Html.div [] [
    Html.button [
      Events.onClick address Refresh
    ]
    [ Html.text "Refresh"
    ],
    Html.text message
  ]


-- Mailbox where you can send a list of actions.
actionsMailbox : Signal.Mailbox (List Action)
actionsMailbox =
  Signal.mailbox []


-- Takes a single action and forwars it to actionsMailbox as multiple actions.
oneActionAddress : Signal.Address Action
oneActionAddress =
  Signal.forwardTo actionsMailbox.address (\action -> [action])


-- The http get for random string.
httpTask : Task.Task Http.Error String
httpTask =
  Http.getString "http://localhost:3000/"


-- Maps task to one that always succeeds.
-- Maps it to a OnRefresh action (and adds it as the payload)
-- Maps the Task into an Effect.
refreshFx : Effects.Effects Action
refreshFx =
  httpTask
    |> Task.toResult
    |> Task.map OnRefresh
    |> Effects.task


-- Takes an action and a model and returns new Model and action.
-- On Action:
-- Refresh -> Returns current model and httpTask converted into an effect.
-- OnRefresh -> Returns httpResult on success and empty string on error as the model.
--Â Returns Effects.none, so no effect.
-- Otherwise (so on NoOp) return original model and no effect.
update : Action -> Model -> (Model, Effects.Effects Action)
update action model =
  case action of
    Refresh ->
      (model, refreshFx)

    OnRefresh result ->
      let message =
        Result.withDefault "" result

      in
        (message, Effects.none)

    _ ->
      (model, Effects.none)


-- Core of the application.
-- 1. Takes a list of actions (from the actionsMailbox)
-- 2. Maps through all actions from the signal calling update on them
-- 2.1. make function modelAndFx that takes a Action (model, Edffects)
--      and returns a updated (Model, Effects.Effects Action)
-- 2.2 Use this function to fold through all Actions in modelAndManyFxs.
-- 2.3 Set initial model to "-" and to no effect.
-- 3 Fold actionsMailbox past with the modelAndManyFxs function
--   (cause each signal can contain multiple actions.)
-- 4 Return a Signal that contains (Model, Effects Action) tuples
modelAndFxSignal : Signal.Signal (Model, Effects.Effects Action)
modelAndFxSignal =
  let
    modelAndFx action (previousModel, _) =
      update action previousModel
    modelAndManyFxs actions (previousModel, _) =
      List.foldl modelAndFx (previousModel, Effects.none) actions
    initial =
      ("-", Effects.none)
    in
      Signal.foldp modelAndManyFxs initial actionsMailbox.signal


-- Signal that contains only the models from modelAndFxSignal
modelSignal : Signal.Signal Model
modelSignal =
  Signal.map fst modelAndFxSignal


-- Signal that contains only the Effects from modelAndFxSignal
fxSignal : Signal.Signal (Effects.Effects Action)
fxSignal =
  Signal.map snd modelAndFxSignal


-- Converts fxSignal into a signal of tasks
-- Port runs these
-- taskSignal picks up results from port and sends them to the mailbox
taskSignal : Signal (Task.Task Effects.Never ())
taskSignal =
  Signal.map (Effects.toTask actionsMailbox.address) fxSignal


-- Maps the modelSignal to the view for displaying.
main : Signal.Signal Html.Html
main =
  Signal.map (view oneActionAddress) modelSignal


-- Runs tasks generated by taskSignal through a port
port runner : Signal (Task.Task Effects.Never ())
port runner =
  taskSignal
